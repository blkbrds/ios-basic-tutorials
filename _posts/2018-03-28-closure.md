---
layout: post
title: Closure
---

# CLOSURE



## Đặt vấn đề:

Trong lập trình, không ít lần chúng ta tạo ra những function tương tác với webservice nhằm thực hiện một nhiệm vụ cụ thể nào đó. Nguyên lý của nó là gửi yêu cầu đi và nhận kết quả về. Nhưng, quá trình này sẽ diễn ra trong bao lâu? Khi nào thì nó kết thúc? Đó là điều hoàn toàn ngẫu nhiên và nó diễn ra bất đồng bộ.

Vậy làm sao để kiểm soát được quá trình này và trả về một thông báo khi nó kết thúc? Sự ra đời của `CLOSURE` sẽ giúp chúng ta giải quyết được những vấn đề trên.



## Closure:

**<u>Khái niệm</u>**: 

***Closure*** là một khối lệnh khép kín dùng để thực hiện một chức năng, nhiệm vụ nào đó.

Closure là một block code, có thể tách ra để tái sử dụng. Hiểu đơn giản hơn thì Closure là function, nhưng khuyết danh. Ta có thể gán Closure vào biến và sử dụng như các kiểu value khác.

 `Closure` trong Swift tương tự như `block` trong Objective-C và `lambdas` trong các ngôn ngữ khác.

**<u>Cách dùng:</u>**

`Closure` có thể truyền đi và sử dụng trong source code của bạn, có thể được gán cho biến hoặc truyền vào function như một tham số.

`Closure` có thể **capture** và lưu giữ các tham chiếu đến bất kì `constants` hoặc `variables` từ ngữ cảnh mà chúng được định nghĩa.

**<u>Cú pháp:</u>**

```
{ (params) -> returnType in
	//statements
}
```

> *Chú ý*: Kiểu optional của closure
>
> ((parameter) -> returnType)?

**<u>*Các dạng Closure:*</u>** Closure có một trong 3 hình thức

- Global function: Closure có tên và không capture bất kì giá trị nào. Là một function bình thường.

  ```swift
  func addTwoNumbers(number1: Int, number2: Int) -> Int {
  	return number1 + number2
  }
  addTwoNumbers(number1: 8, number2: 2) // result is 10
  ```

- Nested functions: (Các hàm lồng nhau) là Closure có tên và có thể capture giá trị khi kết thúc function.

  ```swift
  func chooseStepFunction(backward: Bool) -> (Int) -> Int {
      func stepForward(input: Int) -> Int { return input + 1 }
      func stepBackward(input: Int) -> Int { return input - 1 }
      return backward ? stepBackward : stepForward
  }
  ```

- Closure expressions: Với cú pháp đơn giãn, ngắn gọn. Không cần tên và cũng có thể capture giá trị trong phạm vi ngữ cảnh mà chúng được định nghĩa

  ```swift
  let closure: (Int, Int) -> Int = { (number1, number2) -> Int in
  	return number1 + number2
  }
  closure(8,2) // the result is 10
  ```

> Function và closure là kiểu tham chiếu. VÍ dụ dưới đây, cả `addClosure2` và `addClosure` đều tham chiếu đến cùng một closure trong bộ nhớ.

```
var addClosure:(Int,Int)->Int = { $0 + $1 }
let addClosure2 = addClosure
```



## Rút gọn closure:

### Tự suy luận kiểu dữ liệu

Khi truyền closure vào function như một đối số, Swift có thể suy luận kiểu dữ liệu các tham số của nó và giá trị nó trả về. Ví dụ, phương thức `sorted(by:) ` được gọi với đối số là một mảng `String` và trả về kiểu `Bool`, có kiểu `(String, String) -> Bool`.  Nghĩa là, chúng ta có thể lược bỏ `(String, String)` và `Bool` khi định nghĩa closure này. Dấu mũi tên trả về `->` và cặp ngoặc `()` xung quang tên các tham số cũng có thể được bỏ qua

```
// Full
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})

// Compact
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
```

### Ngầm định kiểu trả về từ Single-Expression Closures

Khi closure được khai báo có kiểu **Single-Expression** có thể trả về đơn biểu thức của nó mà bỏ qua từ khoá `return` khi khai báo, ví du:

```
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
```

### Tên đối số viết tắt

Swift sẽ tự động cung cấp tên đối số viết tắt cho khối lệnh closure, có thể được sử dụng để chỉ các giá trị của đối số trong closure bằng tên `$0` , `$1`, `$2`...

Nếu sử dụng tên đối số viết tắt trong closure, chúng ta có thể bỏ qua danh sách đối số của closure khi định nghĩa, số lượng và kiểu dữ liệu của các đối số viết tắt này sẽ được suy ra từ kiểu dữ liệu mà function mong muốn. Từ khoá `in` cũng có thể được bỏ qua:

```
reversedNames = names.sorted(by: { $0 > $1 } )
```

Trong trường hợp này, `$0` và `$1` ám chỉ đến đối số đầu tiên và thứ hai của closure.

### Phương thức toán tử

Có một cách ngắn hơn để viết biểu thức closure ở trên. Kiểu `String`  trong Swift xác định việc thưc hiện từng chuỗi của toán tử lớn hơn `>` như một phương thức có hai tham số kiểu `String` và trả về một giá trị kiểu `Bool`. Điều này rất phù hợp với phương thức `sorted(by:)`.

```
reversedNames = names.sorted(by: >)
```



## Tralling closure:

***<u>Khái niệm</u>***: Tralling closure là gì?

Trailing closure là cách viết một biểu thức closure nằm ngoài của cặp dấu ngoặc đơn của function chứa nó.

Khi một function hội đủ các yếu tố sau:

- Có tham số là một biểu thức closure.


- Tham số closure này nằm cuối cùng trong danh sách tham số của function đó.
- Biểu thức closure là tham số có phần khối lệnh dài.

Thì bạn có thể sử dụng cú pháp **tralling closure**

Closure dưới đây được viết sau ngoặc đơn khi gọi function, mặc dù nó vẫn là một đối số cho function đó. Khi bạn sử dụng cú pháp tralling closure, bạn không cần phải ghi nhãn đối số khi gọi function.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // function body
}
 
// Dưới đây là cách viết đầy đủ:
 
someFunctionThatTakesAClosure(closure: {
    // closure's body
})
 
// Dưới đây là cách viết sử dụng tralling closure:
 
someFunctionThatTakesAClosure() {
    // trailing closure's body
}
```

Closure `sorted(by:)` ở phần rút gọn closure có thể được viết bên ngoài cặp ngoặc nhọn của funtion như sau:

```swift
reversedNames = names.sorted() { $0 > $1 }
```

Nếu Closure là đối số duy nhất của một function, bạn không cần phải viết cặp ngoặc đơn sau tên function khi gọi:

```swift
reversedNames = names.sorted { $0 > $1 }
```



## Capturing values

Một closure có thể nắm bắt các hằng số và biến từ ngữ cảnh xung quanh lúc nó được định nghĩa. Closure sau đó có thể gán và sửa đổi các giá trị của những hằng số và các biến từ bên trong body của nó, ngay cả khi phạm vi ban đầu mà xác định các hằng số và các biến không còn tồn tại.

Trong Swift, hình thức đơn giản nhất của một closure có thể nắm bắt các giá trị là một function được lồng vào một function khác. Một func được lồng vào một function khác có thể nắm bắt bất kỳ đối số nào của function bên ngoài và cũng có thể nắm bắt bất kỳ hằng số và biến nào được định nghĩa trong function bên ngoài.

Đây là ví dụ về một function có tên là `makeIncrementer`, nó chứa một function con được gọi là `incrementer`. Function `incrementer` lồng nhau () ghi lại hai giá trị `runningTotal` và `amount`, từ ngữ cảnh xung quanh nó. Sau khi nắm bắt các giá trị này, `incrementer` được trả về bởi `makeIncrementer` như là một closure tăng dần số tiền mỗi lần nó được gọi.

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

Kiểu trả về của `makeIncrementer` là `() -> Int` Điều này có nghĩa là nó trả về một function chứ không phải là một giá trị đơn giản.

Function `makeIncrementer(forIncrement:)` tạo một biến có tên `runningTotal`, để lưu trữ tổng số đang chạy hiện tại được trả về, với giá trị khởi tạo là `0`

Function `makeIncrementer(forIncrement:)` có duy nhất một tham số kiểu `Int` với argument label là `forIncrement`, và parameter name là `amount`. Funtionc `makeIncrementer` định nghĩa một functino con được gọi là `incrementer`. Hàm này chỉ cần thêm `amount`, và trả về kết quả `runningTotal`.

Đây là một ví dụ về `makeIncrementer` khi thực hiện:

```swift
let incrementByTen = makeIncrementer(forIncrement: 10)
```

Ví dụ này thiết lập một hằng số được gọi là `incrementByTen` để refer một function `makeIncrementer` mà thêm 10 vào `runningTotal` mỗi khi nó được gọi. 

```swift
incrementByTen()
// returns a value of 10
incrementByTen()
// returns a value of 20
incrementByTen()
// returns a value of 30
```



## Escaping trong Closure:

Một Closure được cho là escaping khỏi một function khi closure được truyền như một đối số cho function, nhưng được gọi sau khi function kết thúc. Có thể viết `@escaping` trước tham số của closure để chỉ ra rằng closure được phép thoát ra khỏi function. 

Nghĩa là, giá trị trả về của một closure có thể lưu trữ trong một biến được định nghĩa bên ngoài function, sau khi funtion đó kết thúc. Ví dụ:

```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
```

> Nhiều function xử lý những chức năng bất đồng bộ thường sử dụng đối số closure như một completion handler. Những function này sẽ trả về kết quả sau khi nó bắt đầu xử lý, tuy nhiên closure sẽ không được gọi cho đến khi hoàn thành function. Vì vậy closure cần phải **escape** để có thể được gọi lại sau khi kết thúc function.



## Autoclosures

Đặt từ khoá `@autoclosure` trước đối số trong closure giúp tự động bọc một cặp ngoặc nhọn xung quanh biểu thức trước khi nó được thông qua một function mà không gây ra lỗi. 

*Ví dụ:*

Tạo một function

```
func someName(closure: () -> Bool) {
    if closure() {
        print("TRUE")
    } else {
        print("FALSE")
    }
}
```

Sẽ không có vấn đề gì xảy  ra khi gọi function trên theo cách thông thường:

```
someName(closure: { 2 > 1 }) //TRUE
```

Nếu bỏ cặp ngoặc nhọn đi, thì có vấn đề gì xảy ra hay không? Hãy thử xem:

```
someName(closure: 2 > 1)
/*
Playground execution failed:

error: Closure.playground:8:21: error: cannot convert value of type 'Bool' to expected argument type '() -> Bool'
someName(closure: 2 > 1)
*/
```

Giờ hãy thử thêm từ khoá `@nonescape` trước cặp ngoặc () của closure khi khai báo function và chạy lại thử xem :D



## Lời kết:

Như vấn đề được đặt ra từ đầu, Closure giúp chúng ta giải quyết những vẫn đề về bất đồng bộ trong Swift, trả về một kết quả khi tương tác với webservice.

Closure được dùng rất nhiều trong source code Swift, nếu biết syntax thì sẽ dễ dàng hơn trong việc đọc source code, nắm được các ưu điểm và ứng dụng đúng lúc sẽ đem lại source code ngắn gọn và hiệu quả hơn…